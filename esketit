#include <iostream>
#include <armadillo>
#include "time.h"
using namespace std;
using namespace arma;

// oppgave 1b:

vec cunt(vec y_new, vec y_array, vec exact, int n);
vec dunt(int n, vec y_array);

int main()
{
    //Declaring vectors and variables
    clock_t start, finish;
    int n=10;
    double h=1./(n+1);
    vec a_array(n-1);
    vec b_array(n);
    vec c_array(n-1); //n-2 som siste indeks
    a_array.fill(-1);
    b_array.fill(2);
    c_array.fill(-1);

    //Declaring step-length h
    vec x(n);
    for(int i=0; i<n; i++) {
        x(i) = (i+1)*h;
    }

    //Defining y and the closed form as given in the project
    vec y_array(n);
    y_array  = h*h*100*exp(-10*(x));
    vec exact(n);
    exact = 1.0-(1.0-exp(-10.0))*(x) - exp(-10.0*(x));

    //Gaussian elimination
    vec b_new(n);
    vec y_new(n); //"new" er tilde
    b_new[0] = b_array[0];
    y_new[0] = y_array[0];
    start = clock();
    for (int i=1; i<n; i++) {
        b_new(i) = b_array(i) - (c_array(i-1)*a_array(i-1))/b_new(i-1);
        y_new(i) = y_array(i) - (y_new(i-1)*a_array(i-1))/b_new(i-1);
    }

    //Calculating vector v from y-tilde and a,b,c-arrays
    vec v(n);
    v(n-1) = y_new(n-1)/b_new(n-1);
    for (int j=n-2;j>=0;j--){
        v(j) = (y_new(j)-c_array(j)*v(j+1))/b_new(j);
    }
    finish = clock();

    //Finding the relative error of the numerical and exact solutions
    vec relErrorr(n);
    for (int j=n-2;j>=0;j--){
        relErrorr = log10(abs((v(j)-exact(j))/exact(j)));
    }

    double time = ((double (finish) - double (start))/CLOCKS_PER_SEC);
    cout << "Time elapsed:"<< time << endl;
    vec fromCunt(n);
    vec fromDunt(n);
    fromCunt=cunt(y_new, y_array, exact, n);
    fromDunt=dunt(n, y_array);
    return 0;
}

// oppgave 1c:
vec cunt(vec y_new, vec y_array, vec exact, int n)
{
//    clock_t start, finish;
    vec b_teller(n);
    vec b_nevner(n);
    vec b_new(n);
    b_teller = regspace<vec>(2,n+1);
    b_nevner = regspace<vec>(1,n);
    b_new = b_teller/b_nevner;
    y_new[0] = y_array[0];

//    start = clock();
    for (int i=1; i<n; i++) {
        y_new(i) = y_array(i) + (y_new(i-1)/b_new(i-1));
    }

    vec v(n);
    v(n-1) = y_new(n-1)/b_new(n-1);
    for (int j=n-2;j>=0;j--){
        v(j) = (y_new(j)+v(j+1))/b_new(j);
    }
//  finish = clock();

    vec relError(n);
    for (int j=n-2;j>=0;j--){
        relError(j) = log10(abs((v(j)-exact(j))/exact(j)));
    }

    return relError;
}

// d

vec dunt(int n, vec y_array)
{
    mat A = zeros(n,n);
    A(n-1,n-1)=2; //for å kun bruke 1 forløkke
    for (int i=0;i<n-1;i++){
        A(i,i)=2;
        A(i,i+1)=-1;
        A(i+1,i)=-1;
    }
  //  start=clock();
    vec sol;
    sol=solve(A,y_array);
  //  finish=clock();

    mat L,U,P;
    vec lusolv;
    lusolv=lu(L,U,P,A);

    return sol;

}
